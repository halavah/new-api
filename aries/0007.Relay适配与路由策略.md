# 0007. Relay 适配与路由策略

## 适合人群
- 有 Java 背景的 Go 初学者，想理解多厂商/多模型转发的核心逻辑。

## 定位
- Relay 是模型/渠道的适配层：接收上层请求，选择合适渠道，转发到具体厂商 API，并处理重试/回退。
- 目录：`relay/`（多级子目录，按渠道/功能拆分）。

## 核心能力
- 渠道选择与权重：根据可用性、权重、用户/模型限制挑选渠道。
- 重试与回退：失败时按策略切换备用渠道。
- 格式转换：不同厂商的请求/响应格式适配（OpenAI/Claude/Gemini 等）。
- 计费/用量：与 service/model 协作，记录与扣费。

## 结构导览
- `relay/relay_task.go`：核心任务调度/路由逻辑。
- `relay/common/`：通用工具与适配辅助。
- `relay/channel/*`：按厂商/能力分类的适配实现（如 aws、task/sora 等）。
- `controller/relay.go`：HTTP 层入口，调用 relay 进行转发。

## 流程（简化）
1) controller/relay 接收请求，解析模型/用户/渠道信息。
2) service/relay 选择渠道（权重、可用性、限制）。
3) 适配层构造下游请求，调用厂商 API。
4) 处理响应/错误，必要时重试或回退，记录计费/用量。
5) 返回统一格式给上层。

## 设计考量
- 解耦：新渠道主要改 relay/channel 与必要的配置，不影响 controller/service/model。
- 可观测：保留日志/错误信息，便于定位下游失败。
- 弹性：支持权重、重试次数、模型映射等配置。

## 对照 Java 习惯
- Relay 类似“策略 + 适配器”组合；无 IOC 容器，需要手工组织依赖。
- 错误通过返回值传递，需显式处理重试/回退逻辑。

## 参考文件
- `relay/relay_task.go`
- `relay/common/`
- `relay/channel/` 下各子目录
- `controller/relay.go`

